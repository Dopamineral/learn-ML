{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Overview"},{"location":"ml/","text":"Chapters: \u00b6 Chapter 2 - Training Simple Machine Learning Algorithms for Classification","title":"Chapters:"},{"location":"ml/#chapters","text":"Chapter 2 - Training Simple Machine Learning Algorithms for Classification","title":"Chapters:"},{"location":"ml/chapter2/","text":"Chapter 2: Training Simple Machine Learning Algorithms for Classification \u00b6 Exercise 1 : Make a virtual environment for your ML projects \u00b6 make a virtual environment in python activate it make a requirements file with numpy, pandas, matplotlib install the requirements file Solution hint Solution google python venv python3 -m venv .venv source .venv bin activatre touch requirements.txt # insert numpy into requirements.txt # insert pandas into requirements.txt # insert matplotlib into requirements.txt pip install -r requirements.txt Exercise 2: Warm up \u00b6 make a main.py file add function that iteratively adds 1 to a number of n amount of cycles. e.g \"my number is a, for something in range n: add 1 to my number. add 'verbose' as key word argument to function that optionally prints out \"hello\" when the function is run Solution hint Solution google defining functions in python it helps if the verbose argument is a boolean # make the file touch main.py main.py def add_stuff ( a , n , verbose = False ): if verbose : print ( \"hello\" ) for ii in range ( n ): a += 1 print ( a ) return a Exercise 3: Key concept 1: classes \u00b6 copy the python code below and try to complete what is missing exercise 3 class Neuron : def __init__ ( self , a ): self . a_value = a def do_something ( self ): print ( self . a_value ) def calculate_something ( self , a , b ): print ( a + b ) neuron1 = Neuron ( 2 ) neuron1 . do_something () neuron1 . calculate_something ( 2 , 3 ) # Ex 1: Run the above stuff and try to explain what is going on # Ex 2: Change the Neuron class so it takes in two arguments # Ex 3: print out the internal values of your neuron object # Ex 4: add a \"calculate\" function to the neuron class that multiplies its internal values Solution hint Solution cheating now are we? # Ex 2: Change the Neuron class so it takes in two arguments class Neuron2 : def __init__ ( self , a , b ): self . a_value = a self . b_value = b def do_something ( self ): print ( self . a_value ) def calculate_something ( self , a , b ): print ( a + b ) neuron2 = Neuron2 ( 2 , 3 ) neuron2 . do_something () neuron2 . calculate_something ( 2 , 3 ) # Ex 3: print out the internal values of your neuron object print ( neuron2 . a_value ) print ( neuron2 . b_value ) # Ex 4: add a \"calculate\" function to the neuron class that multiplies its internal values class Neuron3 : def __init__ ( self , a , b ): self . a_value = a self . b_value = b def do_something ( self ): print ( self . a_value ) def calculate_something ( self , a , b ): print ( a + b ) def calculate ( self ): product = self . a_value * self . b_value print ( product ) Exercise 4: funny thing: the zip function \u00b6 find out what the zip function does and add that to a neuron class to do something fancy Solution hint Solution Realpython has a nice overview of what the zip function does X = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] # train data y = [ 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 ] # test data def combine_train_test ( X , y ): iterator = zip ( X , y ) list_of_iterator = list ( iterator ) print ( list_of_iterator ) Exercise 5: Copy paste the code from the handbook and correct the indentation. \u00b6 this is a nice exercise, for real import numpy as np class Perceptron : \"\"\"Perceptron classifier. Parameters ------------ eta : float Learning rate (between 0.0 and 1.0) n_iter : int Passes over the training dataset. random_state : int Random number generator seed for random weight initialization. Attributes ----------- w_ : 1d-array Weights after fitting. b_ : Scalar Bias unit after fitting. errors_ : list Number of misclassifications (updates) in each epoch. \"\"\" def __init__ ( self , eta = 0.01 , n_iter = 50 , random_state = 1 ): self . eta = eta self . n_iter = n_iter self . random_state = random_state def fit ( self , X , y ): \"\"\"Fit training data. Parameters ---------- X : {array-like}, shape = [n_examples, n_features] Training vectors, where n_examples is the number of examples and n_features is the number of features. y : array-like, shape = [n_examples] Target values. Returns ------- self : object \"\"\" rgen = np . random . RandomState ( self . random_state ) self . w_ = rgen . normal ( loc = 0.0 , scale = 0.01 , size = X . shape [ 1 ]) self . b_ = np . float_ ( 0. ) self . errors_ = [] for _ in range ( self . n_iter ): errors = 0 for xi , target in zip ( X , y ): update = self . eta * ( target - self . predict ( xi )) self . w_ += update * xi self . b_ += update errors += int ( update != 0.0 ) self . errors_ . append ( errors ) return self def net_input ( self , X ): \"\"\"Calculate net input\"\"\" return np . dot ( X , self . w_ ) + self . b_ def predict ( self , X ): \"\"\"Return class label after unit step\"\"\" return np . where ( self . net_input ( X ) >= 0.0 , 1 , 0 ) Exercise 6: plotting data \u00b6 use numpy to create a sin function dataset use matplotlib to plot that data add xlabel and y label add title to the plot (add a legend to the plot) -> extra challenge Solution hint Solution use numpy linspace to create the x-values then you can create y as y=sin(x) import numpy as np import matplotlib.pyplot as plt #create the values x = np . linspace ( 1 , 10 , 100 ) y = np . sin ( x ) #plot the values plt . plot ( x , y ) # add labels plt . xlabel ( \"my fancy x label\" ) plt . ylabel ( \"my fancy y label\" ) # add title plt . title ( \"my fancy title\" ) # add legend plt . legend ([ 'first thing that is plotted' , \"secodn thing that is plotted \" ]) plt . show () Exercise 7: What does the numpy.where function do? \u00b6 make a function that uses this Solution hint Solution the function returns indexes import numpy as np X = np . array ([ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) y = np . array ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]) # check what this output does print ( np . where ( X * y == 0 ))","title":"Chapter2"},{"location":"ml/chapter2/#chapter-2-training-simple-machine-learning-algorithms-for-classification","text":"","title":"Chapter 2: Training Simple Machine Learning Algorithms for Classification"},{"location":"ml/chapter2/#exercise-1-make-a-virtual-environment-for-your-ml-projects","text":"make a virtual environment in python activate it make a requirements file with numpy, pandas, matplotlib install the requirements file Solution hint Solution google python venv python3 -m venv .venv source .venv bin activatre touch requirements.txt # insert numpy into requirements.txt # insert pandas into requirements.txt # insert matplotlib into requirements.txt pip install -r requirements.txt","title":"Exercise 1 : Make a virtual environment for your ML projects"},{"location":"ml/chapter2/#exercise-2-warm-up","text":"make a main.py file add function that iteratively adds 1 to a number of n amount of cycles. e.g \"my number is a, for something in range n: add 1 to my number. add 'verbose' as key word argument to function that optionally prints out \"hello\" when the function is run Solution hint Solution google defining functions in python it helps if the verbose argument is a boolean # make the file touch main.py main.py def add_stuff ( a , n , verbose = False ): if verbose : print ( \"hello\" ) for ii in range ( n ): a += 1 print ( a ) return a","title":"Exercise 2: Warm up"},{"location":"ml/chapter2/#exercise-3-key-concept-1-classes","text":"copy the python code below and try to complete what is missing exercise 3 class Neuron : def __init__ ( self , a ): self . a_value = a def do_something ( self ): print ( self . a_value ) def calculate_something ( self , a , b ): print ( a + b ) neuron1 = Neuron ( 2 ) neuron1 . do_something () neuron1 . calculate_something ( 2 , 3 ) # Ex 1: Run the above stuff and try to explain what is going on # Ex 2: Change the Neuron class so it takes in two arguments # Ex 3: print out the internal values of your neuron object # Ex 4: add a \"calculate\" function to the neuron class that multiplies its internal values Solution hint Solution cheating now are we? # Ex 2: Change the Neuron class so it takes in two arguments class Neuron2 : def __init__ ( self , a , b ): self . a_value = a self . b_value = b def do_something ( self ): print ( self . a_value ) def calculate_something ( self , a , b ): print ( a + b ) neuron2 = Neuron2 ( 2 , 3 ) neuron2 . do_something () neuron2 . calculate_something ( 2 , 3 ) # Ex 3: print out the internal values of your neuron object print ( neuron2 . a_value ) print ( neuron2 . b_value ) # Ex 4: add a \"calculate\" function to the neuron class that multiplies its internal values class Neuron3 : def __init__ ( self , a , b ): self . a_value = a self . b_value = b def do_something ( self ): print ( self . a_value ) def calculate_something ( self , a , b ): print ( a + b ) def calculate ( self ): product = self . a_value * self . b_value print ( product )","title":"Exercise 3: Key concept 1: classes"},{"location":"ml/chapter2/#exercise-4-funny-thing-the-zip-function","text":"find out what the zip function does and add that to a neuron class to do something fancy Solution hint Solution Realpython has a nice overview of what the zip function does X = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] # train data y = [ 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 ] # test data def combine_train_test ( X , y ): iterator = zip ( X , y ) list_of_iterator = list ( iterator ) print ( list_of_iterator )","title":"Exercise 4: funny thing: the zip function"},{"location":"ml/chapter2/#exercise-5-copy-paste-the-code-from-the-handbook-and-correct-the-indentation","text":"this is a nice exercise, for real import numpy as np class Perceptron : \"\"\"Perceptron classifier. Parameters ------------ eta : float Learning rate (between 0.0 and 1.0) n_iter : int Passes over the training dataset. random_state : int Random number generator seed for random weight initialization. Attributes ----------- w_ : 1d-array Weights after fitting. b_ : Scalar Bias unit after fitting. errors_ : list Number of misclassifications (updates) in each epoch. \"\"\" def __init__ ( self , eta = 0.01 , n_iter = 50 , random_state = 1 ): self . eta = eta self . n_iter = n_iter self . random_state = random_state def fit ( self , X , y ): \"\"\"Fit training data. Parameters ---------- X : {array-like}, shape = [n_examples, n_features] Training vectors, where n_examples is the number of examples and n_features is the number of features. y : array-like, shape = [n_examples] Target values. Returns ------- self : object \"\"\" rgen = np . random . RandomState ( self . random_state ) self . w_ = rgen . normal ( loc = 0.0 , scale = 0.01 , size = X . shape [ 1 ]) self . b_ = np . float_ ( 0. ) self . errors_ = [] for _ in range ( self . n_iter ): errors = 0 for xi , target in zip ( X , y ): update = self . eta * ( target - self . predict ( xi )) self . w_ += update * xi self . b_ += update errors += int ( update != 0.0 ) self . errors_ . append ( errors ) return self def net_input ( self , X ): \"\"\"Calculate net input\"\"\" return np . dot ( X , self . w_ ) + self . b_ def predict ( self , X ): \"\"\"Return class label after unit step\"\"\" return np . where ( self . net_input ( X ) >= 0.0 , 1 , 0 )","title":"Exercise 5: Copy paste the code from the handbook and correct the indentation."},{"location":"ml/chapter2/#exercise-6-plotting-data","text":"use numpy to create a sin function dataset use matplotlib to plot that data add xlabel and y label add title to the plot (add a legend to the plot) -> extra challenge Solution hint Solution use numpy linspace to create the x-values then you can create y as y=sin(x) import numpy as np import matplotlib.pyplot as plt #create the values x = np . linspace ( 1 , 10 , 100 ) y = np . sin ( x ) #plot the values plt . plot ( x , y ) # add labels plt . xlabel ( \"my fancy x label\" ) plt . ylabel ( \"my fancy y label\" ) # add title plt . title ( \"my fancy title\" ) # add legend plt . legend ([ 'first thing that is plotted' , \"secodn thing that is plotted \" ]) plt . show ()","title":"Exercise 6: plotting data"},{"location":"ml/chapter2/#exercise-7-what-does-the-numpywhere-function-do","text":"make a function that uses this Solution hint Solution the function returns indexes import numpy as np X = np . array ([ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) y = np . array ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]) # check what this output does print ( np . where ( X * y == 0 ))","title":"Exercise 7: What does the numpy.where function do?"}]}